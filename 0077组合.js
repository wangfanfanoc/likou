//回溯法
/* 
回溯法:采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，
    当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步
    甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。
    回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
                      找到一个可能存在的正确的答案；
                      在尝试了所有可能的分步方法后宣告该问题没有答案。


深度优先搜索 算法（DFS）:
    是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。
    当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。
    这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点
    ，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。


 「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「
  回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，
  搜索需要的结果。强调了 回退 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，
  与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。
 
   回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。



模板
先画树形图
void backtracking(参数) {
    if (终⽌条件) {
      存放结果;
      return;}
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
      处理节点;
      backtracking(路径，选择列表);//递归
      回溯，
      撤销处理结果
    }
} 

 每个节点分支的个数由for循环决定, 树的深度由递归决定
*/

var combine = function (n, k) {
  let arr = [];
  let result = [];
  dfs = (arr, n, k, start) => {
    if (arr.length == k) {
      //递归结束的条件
      result.push([...arr]);
      return;
    }
    for (let i = start; i <= n; i++) {
      //for决定每个节点的分支数
      arr.push(i);
      dfs(arr, n, k, i + 1); //递归 决定每个子树的深度
      arr.pop(); //递归完成后，回溯到当前一层,继续进行操作
    }
  };

  dfs(arr, n, k, 1);
  return result;
};
